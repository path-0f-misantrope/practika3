package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
)

const (
	dsn        = "postgres://postgres:zxcqwe123@localhost:5432/postgres" // Взято из main.go
	outputFile = "dump.sql"
)

func main() {
	ctx := context.Background()

	// Подключение к БД
	conn, err := pgx.Connect(ctx, dsn)
	if err != nil {
		log.Fatalf("Не удалось подключиться к БД: %v", err)
	}
	defer conn.Close(ctx)

	f, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("Ошибка создания файла дампа: %v", err)
	}
	defer f.Close()

	log.Println("Начало создания дампа...")

	// 1. Запись схемы
	schema := `
-- Postgres Database Dump
-- Generated by custom tool
-- Date: ` + time.Now().Format(time.RFC3339) + `

BEGIN;

-- Table: users
CREATE TABLE IF NOT EXISTS users (
    user_id SERIAL PRIMARY KEY,
    fio TEXT NOT NULL,
    phone TEXT NOT NULL,
    login TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,
    type TEXT NOT NULL
);

-- Table: requests
CREATE TABLE IF NOT EXISTS requests (
    request_id SERIAL PRIMARY KEY,
    start_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    climate_tech_type TEXT NOT NULL,
    climate_tech_model TEXT NOT NULL,
    problem_description TEXT NOT NULL,
    request_status TEXT DEFAULT 'Новая заявка',
    completion_date TIMESTAMP WITH TIME ZONE,
    repair_parts TEXT,
    manager_comment TEXT,
    master_id INT REFERENCES users(user_id),
    client_id INT REFERENCES users(user_id) NOT NULL
);

`
	if _, err := f.WriteString(schema); err != nil {
		log.Fatalf("Ошибка записи схемы: %v", err)
	}

	// 2. Дамп данных таблицы users
	if err := dumpUsers(ctx, conn, f); err != nil {
		log.Fatalf("Ошибка дампа users: %v", err)
	}

	// 3. Дамп данных таблицы requests
	if err := dumpRequests(ctx, conn, f); err != nil {
		log.Fatalf("Ошибка дампа requests: %v", err)
	}

	if _, err := f.WriteString("COMMIT;\n"); err != nil {
		log.Fatalf("Ошибка записи COMMIT: %v", err)
	}

	log.Printf("Дамп успешно создан: %s", outputFile)
}

func dumpUsers(ctx context.Context, conn *pgx.Conn, f *os.File) error {
	rows, err := conn.Query(ctx, "SELECT user_id, fio, phone, login, password, type FROM users ORDER BY user_id")
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		var id int
		var fio, phone, login, password, userType string
		if err := rows.Scan(&id, &fio, &phone, &login, &password, &userType); err != nil {
			return err
		}

		// Экранирование строк (простейшее, для ' и \)
		fio = escapeString(fio)
		phone = escapeString(phone)
		login = escapeString(login)
		password = escapeString(password)
		userType = escapeString(userType)

		query := fmt.Sprintf("INSERT INTO users (user_id, fio, phone, login, password, type) VALUES (%d, '%s', '%s', '%s', '%s', '%s') ON CONFLICT (user_id) DO NOTHING;\n",
			id, fio, phone, login, password, userType)

		if _, err := f.WriteString(query); err != nil {
			return err
		}
	}
	// Обновляем sequence
	if _, err := f.WriteString("SELECT setval('users_user_id_seq', (SELECT MAX(user_id) FROM users));\n\n"); err != nil {
		return err
	}

	return nil
}

func dumpRequests(ctx context.Context, conn *pgx.Conn, f *os.File) error {
	rows, err := conn.Query(ctx, `
		SELECT request_id, start_date, climate_tech_type, climate_tech_model, 
		       problem_description, request_status, completion_date, repair_parts, 
		       manager_comment, master_id, client_id 
		FROM requests ORDER BY request_id
	`)
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		var id, clientID int
		var masterID *int
		var startDate, completionDate *time.Time
		var techType, techModel, desc, status string
		var parts, comment *string

		if err := rows.Scan(&id, &startDate, &techType, &techModel, &desc, &status, &completionDate, &parts, &comment, &masterID, &clientID); err != nil {
			return err
		}

		valMasterID := "NULL"
		if masterID != nil {
			valMasterID = fmt.Sprintf("%d", *masterID)
		}

		valParts := "NULL"
		if parts != nil {
			valParts = fmt.Sprintf("'%s'", escapeString(*parts))
		}

		valComment := "NULL"
		if comment != nil {
			valComment = fmt.Sprintf("'%s'", escapeString(*comment))
		}

		valCompDate := "NULL"
		if completionDate != nil {
			valCompDate = fmt.Sprintf("'%s'", completionDate.Format(time.RFC3339))
		}

		valStartDate := "NULL"
		if startDate != nil {
			valStartDate = fmt.Sprintf("'%s'", startDate.Format(time.RFC3339))
		}

		query := fmt.Sprintf(
			"INSERT INTO requests (request_id, start_date, climate_tech_type, climate_tech_model, problem_description, request_status, completion_date, repair_parts, manager_comment, master_id, client_id) VALUES (%d, %s, '%s', '%s', '%s', '%s', %s, %s, %s, %s, %d) ON CONFLICT (request_id) DO NOTHING;\n",
			id, valStartDate, escapeString(techType), escapeString(techModel), escapeString(desc), escapeString(status), valCompDate, valParts, valComment, valMasterID, clientID,
		)

		if _, err := f.WriteString(query); err != nil {
			return err
		}
	}
	// Обновляем sequence
	if _, err := f.WriteString("SELECT setval('requests_request_id_seq', (SELECT MAX(request_id) FROM requests));\n\n"); err != nil {
		return err
	}

	return nil
}

func escapeString(s string) string {
	return strings.ReplaceAll(s, "'", "''")
}
